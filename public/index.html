<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script id="vs" type="x-shader/x-vertex">
        attribute vec4 position;
        attribute vec3 normal;
        attribute vec2 texcoord;

        void main() {
          gl_Position =  position;
        }
          
    </script>
    <script id="fs" type="x-shader/x-fragment">

        #define PI 3.1415926535897932384626433832795
        #define MAX_MARCHING_STEPS 100
        #define MAX_INSTRUCTIONS 1000

        #ifdef GL_ES
        precision mediump float;
        #endif

        float pixel2float(vec4 pixel) {
            float rByte = pixel.r * 255.0;
            float gByte = pixel.g * 255.0;
            float bByte = pixel.b * 255.0;
            float aByte = pixel.a * 255.0;

            float s = -step(127.0, aByte);
            float eLastBit = step(127.0, bByte);
            float e = (aByte + s * 128.0) * 2.0 + eLastBit;
            float m = (bByte - eLastBit * 128.0) * 65536.0 + gByte * 256.0 + rByte;
            float f = (s * 2.0 + 1.0) * (1.0 + m / 8388608.0) * pow(2.0, e - 127.0);
            return f;
        }

        float getCardFloat(sampler2D code, inout float pos, float width, float height) {
            float y = pos / width;
            float x = pos - y * width;
            vec2 uv = vec2(x / width, y / height);
            vec4 pixel = texture2D(code, uv);
            pos++;
            return pixel2float(pixel);
        }

        float getCardVector(sampler2D code, inout float pos, float width, float height) {
            vec3 v;
            v.x = getCardFloat(code, pos, width, height);
            v.y = getCardFloat(code, pos, width, height);
            v.z = getCardFloat(code, pos, width, height);
            return v;
        }
        
        mat4 getCardMatrix(sampler2D code, inout float pos, float width, float height) {
            mat4 m;
            m[0] = getCardVector(code, pos, width, height);
            m[1] = getCardVector(code, pos, width, height);
            m[2] = getCardVector(code, pos, width, height);
            m[3] = getCardVector(code, pos, width, height);
            return m;
        }

        struct Registers{
            float   memory[100];
            mat4    r[2];           // 0
            float   pos;            // 1000
            float   esp;            // 1001
        };

        struct PCInput{
            float argf[100];
            sampler2D argt[10];
        };

        struct PCOutput{
            float data[100];
        };

        uniform PCInput pc_input;
        uniform sampler2D pc_code;
        PCOutput pc_output;

        void run(sampler2D code) {
            pc_output.code = 0.0;
            Registers regs;
            regs.pos = 0.0;
            regs.esp = 100.0;
            float width = getCardFloat(code, regs.pos, 100.0, 100.0);
            float height = getCardFloat(code, regs.pos, width, 100.0);

            float op = getCardFloat(code, regs.pos, width, height);
            for(int i = 0; i < MAX_INSTRUCTIONS; i++) {
                if(op == 0.0) { // exit
                    break;                      
                }

                if(abs(op) == 1.0) { // mov
                    float movDest = getCardFloat(code, regs.pos, width, height);
                    if(movDest >= 1000) { // other register
                        if(movDest == 1000) {
                            if(op > 0) { // from register or memory
                                int b = int(getCardFloat(code, regs.pos, width, height));
                                if(b >= 0) { // from float register
                                    int matIndex = b / 16;
                                    int vecIndex = b / 4;
                                    int floatIndex = b;
                                    regs.pos = regs.r[matIndex][vecIndex][floatIndex];
                                }else { // from memory
                                    regs.pos = regs.memory[-b];
                                }
                            } else { // from constant
                                float b = getCardFloat(code, regs.pos, width, height);
                                regs.pos = b;
                            }
                        }else if(movDest == 1001) {
                        }
                    }else if(movDest >= 100) { // matrix register

                    }else if(movDest >= 10) { // vector register

                    }else if(movDest >= 0) { // float register

                    }else { // memory

                    }
                }
                op = getCardFloat(code, regs.pos, width, height);
            }
        }

        void main() {
            run(pc_code);
            gl_FragColor = vec4(pc_output.data[0], pc_output.data[1], pc_output.data[2], pc_output.data[3]);
        }
          
    </script>
    <canvas id="c"></canvas>
</body>

</html>